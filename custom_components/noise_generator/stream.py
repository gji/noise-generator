"""Streaming helpers for the Noise Generator integration."""

from __future__ import annotations

import asyncio
import contextlib
import json
import logging
import sys
from dataclasses import dataclass
from typing import Any
from urllib.parse import quote

from aiohttp import client_exceptions as aiohttp_client_exceptions
from aiohttp import web

from homeassistant.components.http import HomeAssistantView
from homeassistant.const import EVENT_HOMEASSISTANT_STOP
from homeassistant.core import HomeAssistant
try:  # pragma: no cover - compatibility with older HA releases
    from homeassistant.helpers.network import async_get_url
except ImportError:  # pragma: no cover - fallback for newer HA versions
    from homeassistant.helpers.network import get_url as _sync_get_url

    async def async_get_url(hass: HomeAssistant, **kwargs) -> str:
        """Async wrapper around sync get_url for newer Home Assistant builds."""

        return _sync_get_url(hass, **kwargs)
from homeassistant.util import slugify

from .const import (
    CONF_PROFILE_NAME,
    CONF_PROFILE_PARAMETERS,
    CONF_PROFILE_SUBTYPE,
    CONF_PROFILE_TYPE,
    CONF_SEED,
    CONF_VOLUME,
    DEFAULT_PROFILE_NAME,
    DEFAULT_PROFILE_SUBTYPE,
    DEFAULT_PROFILE_TYPE,
    DOMAIN,
    MEDIA_MIME_TYPE,
    SAMPLE_RATE,
    STREAM_CHUNK_DURATION,
    STREAM_URL_PATH,
    STDOUT_READ_SIZE,
)
from .noise import coerce_profile

_LOGGER = logging.getLogger(__name__)


@dataclass
class NoiseStreamProfile:
    """Representation of a playable noise profile."""

    slug: str
    name: str
    definition: dict[str, Any]


class NoiseStreamView(HomeAssistantView):
    """Serve streaming audio responses for configured noise profiles."""

    url = f"{STREAM_URL_PATH}/{{entry_id}}/{{slug}}"
    name = "api:noise_generator:stream"
    requires_auth = False

    def __init__(self, hass: HomeAssistant) -> None:
        self.hass = hass

    async def get(self, request: web.Request, entry_id: str, slug: str) -> web.StreamResponse:
        domain_data = self.hass.data.get(DOMAIN, {})
        entries: dict[str, Any] = domain_data.get("entries", {})
        stored = entries.get(entry_id)
        if stored is None:
            raise web.HTTPNotFound()

        manager: NoiseStreamManager = stored["manager"]
        profile = manager.get_profile(slug)
        if profile is None:
            raise web.HTTPNotFound()

        return await manager.async_stream_profile(request, profile)


class NoiseStreamManager:
    """Manage runtime state for streaming noise profiles."""

    def __init__(self, hass: HomeAssistant, entry_id: str) -> None:
        self.hass = hass
        self.entry_id = entry_id
        self._profiles: dict[str, NoiseStreamProfile] = {}
        self._handles: set[_BaseStreamHandle] = set()
        self._ha_stop_unsub = hass.bus.async_listen_once(
            EVENT_HOMEASSISTANT_STOP, self._async_handle_ha_shutdown
        )

    def update_profiles(self, profiles: list[dict[str, Any]]) -> None:
        """Refresh the available profile definitions."""

        new_profiles: dict[str, NoiseStreamProfile] = {}
        used_slugs: set[str] = set()
        for index, profile in enumerate(profiles):
            name = str(profile.get(CONF_PROFILE_NAME) or DEFAULT_PROFILE_NAME)
            slug_base = slugify(name) or slugify(f"profile-{index + 1}")
            slug_candidate = slug_base
            suffix = 2
            while slug_candidate in used_slugs:
                slug_candidate = f"{slug_base}-{suffix}"
                suffix += 1
            used_slugs.add(slug_candidate)
            definition = {CONF_PROFILE_NAME: name, **coerce_profile(profile)}
            new_profiles[slug_candidate] = NoiseStreamProfile(
                slug=slug_candidate,
                name=name,
                definition=definition,
            )

        self._profiles = new_profiles

    def iter_profiles(self) -> list[NoiseStreamProfile]:
        """Return all stored profiles sorted by display name."""

        return sorted(self._profiles.values(), key=lambda item: item.name.lower())

    def get_profile(self, slug: str) -> NoiseStreamProfile | None:
        """Return a profile by slug."""

        return self._profiles.get(slug)

    async def async_build_stream_url(self, slug: str) -> str:
        """Return an absolute URL that streams the requested profile."""

        base_url = await async_get_url(self.hass, prefer_external=False)
        base = base_url.rstrip("/")
        return f"{base}{STREAM_URL_PATH}/{self.entry_id}/{quote(slug)}"

    async def async_stream_profile(
        self, request: web.Request, profile: NoiseStreamProfile
    ) -> web.StreamResponse:
        """Stream audio generated by the active engine for the given profile."""

        handle = await self._create_process_handle(profile)

        response = web.StreamResponse(
            status=200,
            headers={
                "Content-Type": MEDIA_MIME_TYPE,
                "Cache-Control": "no-store",
            },
        )
        response.enable_chunked_encoding()
        await response.prepare(request)

        try:
            while True:
                chunk = await handle.read_chunk()
                if not chunk:
                    break
                await response.write(chunk)
        except asyncio.CancelledError:
            raise
        except (ConnectionResetError, asyncio.IncompleteReadError):
            pass
        finally:
            await handle.close()
            with contextlib.suppress(
                RuntimeError,
                ConnectionError,
                aiohttp_client_exceptions.ClientConnectionError,
            ):
                await response.write_eof()

        return response

    async def async_shutdown(self) -> None:
        """Clean up any lingering stream handles."""

        handles = list(self._handles)
        if handles:
            await asyncio.gather(*(handle.close() for handle in handles), return_exceptions=True)
        self._handles.clear()
        if self._ha_stop_unsub is not None:
            self._ha_stop_unsub()
            self._ha_stop_unsub = None

    async def _async_handle_ha_shutdown(self, _event) -> None:
        self._ha_stop_unsub = None
        await self.async_shutdown()

    async def _create_process_handle(self, profile: NoiseStreamProfile) -> _BaseStreamHandle:
        process = await self._launch_process(profile)
        stderr_task = self.hass.async_create_task(
            self._forward_stderr(profile.slug, process),
            name=f"noise_generator_stderr_{profile.slug}",
        )
        return _ProcessStreamHandle(self, process, stderr_task)

    async def _launch_process(self, profile: NoiseStreamProfile) -> asyncio.subprocess.Process:
        """Launch the subprocess that produces streaming audio."""

        params = dict(profile.definition[CONF_PROFILE_PARAMETERS])
        profile_type = profile.definition.get(CONF_PROFILE_TYPE, DEFAULT_PROFILE_TYPE)
        profile_subtype = profile.definition.get(CONF_PROFILE_SUBTYPE, DEFAULT_PROFILE_SUBTYPE)
        parameters_payload = json.dumps(params, separators=(",", ":"))
        _LOGGER.debug(
            "Launching profile slug=%s mode=%s subtype=%s params=%s",
            profile.slug,
            profile_type,
            profile_subtype,
            params,
        )
        args = [
            sys.executable,
            "-m",
            "custom_components.noise_generator.noise_process",
            "--mode",
            profile_type,
            "--subtype",
            profile_subtype,
            "--volume",
            str(params[CONF_VOLUME]),
            "--sample-rate",
            str(SAMPLE_RATE),
            "--chunk-duration",
            str(STREAM_CHUNK_DURATION),
            "--parameters",
            parameters_payload,
        ]
        seed = params.get(CONF_SEED)
        if seed is not None:
            args.extend(["--seed", str(seed)])

        return await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

    async def _forward_stderr(
        self, slug: str, process: asyncio.subprocess.Process
    ) -> None:
        """Drain stderr from the worker process for debugging."""

        assert process.stderr is not None
        try:
            while True:
                line = await process.stderr.readline()
                if not line:
                    break
                _LOGGER.debug("[%s] %s", slug, line.decode(errors="ignore").rstrip())
        except asyncio.CancelledError:
            raise


class _BaseStreamHandle:
    """Protocol for stream handles."""

    async def read_chunk(self) -> bytes:  # pragma: no cover - interface only
        raise NotImplementedError

    async def close(self) -> None:  # pragma: no cover - interface only
        raise NotImplementedError


class _ProcessStreamHandle(_BaseStreamHandle):
    """Manage lifecycle for a subprocess-backed stream."""

    def __init__(
        self,
        manager: NoiseStreamManager,
        process: asyncio.subprocess.Process,
        stderr_task: asyncio.Task[None],
    ) -> None:
        self._manager = manager
        self._process = process
        self._stderr_task = stderr_task
        self._stdout = process.stdout
        self._closed = False

    async def read_chunk(self) -> bytes:
        if self._stdout is None or self._closed:
            return b""
        return await self._stdout.read(STDOUT_READ_SIZE)

    async def close(self) -> None:
        if self._closed:
            return
        self._closed = True

        process = self._process
        if process.returncode is None:
            process.terminate()
            try:
                await asyncio.wait_for(process.wait(), timeout=5)
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()

        self._stdout = None
        if self._stderr_task:
            self._stderr_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._stderr_task
        self._manager._handles.discard(self)


def _coerce_seed(seed: Any | None) -> Any | None:
    if seed in (None, "", "None"):
        return None
    try:
        return int(seed)
    except (TypeError, ValueError):
        return seed
